# -*- coding: utf-8 -*-
"""
Matthew Allcock
"""

import numpy as np
import matplotlib.pyplot as plt
import draw

"""
Pseudo-code

- Set parameters of normal distribution
- Repeat:
    - Player 1: Draw value from this distribution
    - Player 2: Draw value from this distribution
    - until both players have decided to stop.
- Calculate scores - highest number drawn minus number of draws.


Possible extensions:
- Distribution parameters: random? chosen by player? 3rd party?
  how about not normal?
- play against computer - different ability?
- n players.
"""

class Game:
    def __init__(self, n_players, dist_type, dist_params, penalty):
        """
        Inputs:
            n_players = number of player (int),
            dist_type = type of distribution from which players draw
                        ("normal", "uniform", "lomax")
            dist_params = parameters of the distribution from which players
                          draw (list)
        """

        self.n_players = n_players
        self.dist_type = dist_type
        self.dist_params = dist_params
        self.penalty = penalty
        
        # Initialise arrays for draws and scores.
        self.draws = np.empty(self.n_players)
        self.draws[:] = np.nan
        self.score = np.zeros((1, self.n_players))
        self.max_draw = np.empty(self.n_players)
        self.player_draw_num = np.ones(self.n_players).astype(int)
        
        # Initialise an array of truth values. False if no longer drawing numbers.
        self.redraw = np.ones(self.n_players, dtype=bool)
    
    def run_game(self):
        # Draw counters
        draw_num = 0
        
        new_score = np.empty(self.n_players)
        
        while np.any(self.redraw):
            draw_num += 1
            print("\n\n**************** Draw number " + str(draw_num) +
                  " ****************")
            
            # Everyone must draw first
            if draw_num == 1:
                # loop through players
                for j in range(self.n_players):
                    new_draw = draw.draw(self.dist_type, self.dist_params)
                    self.max_draw[j] = new_draw
                    new_score[j] = self.max_draw[j] - self.penalty*self.player_draw_num[j]
                    print("Drew " + str(new_draw) + ", Player " + str(j + 1) +
                          " max draw is " + str(self.max_draw[j]) + ". Current score is " +
                          str(new_score[j]))
                self.score[0, :] = new_score
        
            # In subsequent draws, each player can choose to draw or not
            if draw_num > 1:
                # loop through players
                for j in range(self.n_players):
                    if self.redraw[j] == False:
                        print("Player " + str(j + 1) + " is no longer drawing. "
                              "Max draw is " + str(self.max_draw[j]) + ".")
                        continue
                    val = input("Player " + str(j + 1) + " redraw? (y, n)")
                    if val == "y":
                        self.player_draw_num[j] += 1
                        self.redraw[j] = True
                        new_draw = draw.draw(self.dist_type, self.dist_params)
                        self.max_draw[j] = max(self.max_draw[j], new_draw)
                        new_score[j] = self.max_draw[j] - self.penalty*self.player_draw_num[j]
                        print("Drew " + str(new_draw) + ", Player " + str(j + 1) +
                              " max draw is " + str(self.max_draw[j]) +
                              ". Current score is " + str(new_score[j]))
                    elif val == "n":
                        self.redraw[j] = False
                        print("No draw. Player " + str(j + 1) +
                              " max draw is " + str(self.max_draw[j]) +
                              ". Current score is " + str(new_score[j]))
                        continue
                    else:
                        raise ValueError('Input must be "y" or "n".')
        
                if np.any(self.redraw):
                    # Stack latest score in array with previous scores
                    self.score = np.vstack((self.score, new_score))
        
        print("\n\n**************** Game ended after " + str(draw_num) +
              " draws ****************")
        
        # Print end game info
        for j in range(self.n_players):
            print("Player " + str(j + 1) + " drew " + str(int(self.player_draw_num[j])) +
                  " numbers.")
        print("Final scores: " + str(self.score[-1,:]))
        print("\nWinner is Player " + str(np.argmax(self.score[-1]) + 1) + ".")


    def plot_scores(self):
        # Plot scores against number of draws for each player
        for j in range(self.n_players):
            label = "Player " + str(j + 1)
            plt.plot(list(range(1, max(self.player_draw_num) + 1)), self.score[:, j], label=label)
            plt.scatter(self.player_draw_num[j], self.score[self.player_draw_num[j] - 1, j])
        
        # Set axis labels
        plt.xlabel("Number of draws")
        plt.ylabel("Score")
        
        # Add legend
        plt.legend()


game = Game(2, "normal", [20,5], 1)
game.run_game()
game.plot_scores()

