# -*- coding: utf-8 -*-
"""
Matthew Allcock
"""

import numpy as np
import matplotlib.pyplot as plt
import draw
import strategies as strat

"""
Pseudo-code

- Set parameters of normal distribution
- Repeat:
    - Player 1: Draw value from this distribution
    - Player 2: Draw value from this distribution
    - until both players have decided to stop.
- Calculate scores - highest number drawn minus number of draws.


Possible extensions:
- Distribution parameters: random? chosen by player? 3rd party?
  how about not normal?
- play against computer - different ability?
- n players.
"""

class Game:
    def __init__(self, n_players, dist_type, dist_params, penalty):
        """
        Inputs:
            n_players = number of player (int),
            dist_type = type of distribution from which players draw
                        ("normal", "uniform", "lomax")
            dist_params = parameters of the distribution from which players
                          draw (list)
        """

        self.n_players = n_players
        self.dist_type = dist_type
        self.dist_params = dist_params
        self.penalty = penalty
        
        # Initialise arrays for draws and scores.
        self.draws = np.empty((1, self.n_players))
        self.draws[:] = np.nan
        self.score = np.zeros((1, self.n_players))
        self.max_draw = np.empty(self.n_players)
        self.player_draw_num = np.ones(self.n_players).astype(int)
        
        # Initialise an array of truth values. False if no longer drawing numbers.
        self.redraw = np.ones(self.n_players, dtype=bool)
    
    def run_game(self, human=True, strategy=None):
        """
        Inputs:
            human (bool) = are the players human?
            strategy (string: "perfect", "partial") = what strategy are AI
                                                      players following?
        """
        
        if human:
            printing = True
        else:
            printing = False

        # Draw counters
        draw_num = 0
        
        new_score = np.empty(self.n_players)
        new_draw = np.empty(self.n_players)
        
        while np.any(self.redraw):
            draw_num += 1
            if printing:
                print("\n\n**************** Draw number " + str(draw_num) +
                      " ****************")
            
            # Everyone must draw first
            if draw_num == 1:
                # loop through players
                
                for j in range(self.n_players):
                    new_draw[j] = draw.draw(self.dist_type, self.dist_params)
                    self.max_draw[j] = new_draw[j]
                    new_score[j] = self.max_draw[j] - self.penalty*self.player_draw_num[j]
                    if printing:
                        print("Drew " + str(new_draw[j]) + ", Player " + str(j + 1) +
                              " max draw is " + str(self.max_draw[j]) + ". Current score is " +
                              str(new_score[j]))

                self.score[0, :] = new_score
                self.draws[0, :] = new_draw
            # In subsequent draws, each player can choose to draw or not
            if draw_num > 1:
                # loop through players
                for j in range(self.n_players):
                    if self.redraw[j] == False:
                        new_draw[j] = np.nan
                        if printing:
                            print("Player " + str(j + 1) + " is no longer drawing. "
                                  "Max draw is " + str(self.max_draw[j]) +
                                  ". Score is " + str(new_score[j]))
                        continue
                    if human:
                        val = input("Player " + str(j + 1) + " redraw? (y, n)")
                        if val =="y":
                            self.redraw[j] = True
                        elif val == "n":
                            self.redraw[j] = False
                        else:
                            raise ValueError('Input must be "y" or "n".')
                    else:
                        self.redraw[j] = strat.to_redraw(strategy[j],
                                                         self.dist_type,
                                                         self.dist_params,
                                                         self.penalty,
                                                         self.draws[:,j])
                    if self.redraw[j] == True:
                        self.player_draw_num[j] += 1
                        new_draw[j] = draw.draw(self.dist_type, self.dist_params)
                        self.max_draw[j] = max(self.max_draw[j], new_draw[j])
                        new_score[j] = self.max_draw[j] - self.penalty*self.player_draw_num[j]
                        if printing:
                            print("Drew " + str(new_draw[j]) + ", Player " + str(j + 1) +
                                  " max draw is " + str(self.max_draw[j]) +
                                  ". Current score is " + str(new_score[j]))
                    elif self.redraw[j] == False:
                        new_draw[j] = np.nan
                        if printing:
                            print("No draw. Player " + str(j + 1) +
                                  " max draw is " + str(self.max_draw[j]) +
                                  ". Current score is " + str(new_score[j]))
                        continue
                    else:
                        raise ValueError('strat.to_draw did not return True or False.')
        
                if np.any(self.redraw):
                    # Stack latest score in array with previous scores
                    self.score = np.vstack((self.score, new_score))
                    self.draws = np.vstack((self.draws, new_draw))
        
        if printing:
            print("\n\n**************** Game ended after " +
                  str(draw_num - 1) + " draws ****************")
        
        if printing:
            # Print end game info
            for j in range(self.n_players):
                print("Player " + str(j + 1) + " drew " + str(int(self.player_draw_num[j])) +
                      " numbers.")
            print("Final scores: " + str(self.score[-1,:]))
            print("\nWinner is Player " + str(np.argmax(self.score[-1]) + 1) + ".")
            
        return [self.score, self.draws]


    def plot_scores(self):
        # Plot scores against number of draws for each player
        for j in range(self.n_players):
            label = "Player " + str(j + 1)
            plt.plot(list(range(1, max(self.player_draw_num) + 1)), self.score[:, j], label=label)
            plt.scatter(self.player_draw_num[j], self.score[self.player_draw_num[j] - 1, j])
        
        # Set axis labels
        plt.xlabel("Number of draws")
        plt.ylabel("Score")
        
        # Add legend
        plt.legend()


#game = Game(2, "normal", [10,2], 0.01)

##game = Game(10, "lomax", [2,1,1], 0.1)
#game.run_game(human=False, strategy=["perfect", "partial"])
#game.plot_scores()

n_games = 1000

n_draws_perfect = np.empty(n_games)
n_draws_partial = np.empty(n_games)

scores_perfect = np.empty(n_games)
scores_partial = np.empty(n_games)

for i in range(n_games):
    game = Game(2, "normal", [0,1], 0.01)
    game_scores, game_draws = game.run_game(human=False, strategy=["perfect", "partial"])
    n_draws_perfect[i] = np.count_nonzero(~np.isnan(game_draws[:,0]))
    n_draws_partial[i] = np.count_nonzero(~np.isnan(game_draws[:,1]))
    scores_perfect[i] = game_scores[-1, 0]
    scores_partial[i] = game_scores[-1, 1]
#    print(n_draws_perfect[i])

av_n_draws_perfect = np.mean(n_draws_perfect)
av_n_draws_partial = np.mean(n_draws_partial)

av_score_perfect = np.mean(scores_perfect)
av_score_partial = np.mean(scores_partial)


print("average number of draws are: ", av_n_draws_perfect, av_n_draws_partial)
print("average scores are: ", av_score_perfect, av_score_partial)
